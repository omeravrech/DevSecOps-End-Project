pipeline {
    agent any
    environment {
        FRONT_PORT = 3000
        BACK_PORT = 5000
        DB_PORT = 27107
        DOCKER_REPO_NAME="omeravrech"
        SSH_KEYS_FOLDER="~/.ssh/production/"
        DB_CONNECTION="mongo://1.1.1.1:27017/chat"
    }
    stages {
        stage("Terraform") {
            steps {
                withCredentials([[$class: 'AmazonWebServicesCredentialsBinding',credentialsId: "aws-cre"]]) {
                    sh 'terraform -chdir="./terraform" init'
                    sh 'terraform -chdir="./terraform" apply -auto-approve'
                }
            }
        }
        stage("Prepare Ansible") {
            steps {
                script {
                    // Save new machines certificates
                    sh "mkdir -p ${env.SSH_KEYS_FOLDER}"
                    sh "terraform -chdir='./terraform' output backend_private_key > ${env.SSH_KEYS_FOLDER}/backend_private_key.pem"
                    sh "chmod 600 ${env.SSH_KEYS_FOLDER}/backend_private_key.pem"
                    sh "terraform -chdir='./terraform' output frontend_private_key > ${env.SSH_KEYS_FOLDER}/frontend_private_key.pem"
                    sh "chmod 600 ${env.SSH_KEYS_FOLDER}/frontend_private_key.pem"

                    // Creating Ansible inventory file based on terraform outputs
                    def backend_ip = sh 'terraform -chdir="./terraform" output backend_public_ip'
                    def frontend_ip = sh 'terraform -chdir="./terraform" output frontend_public_ip'
                    sh """echo << EOF
backend_cluster:
    hosts:
        backend1:
            ansible_ssh_host: "${backend_ip}"
            ansible_ssh_port: 22
            ansible_ssh_user: ubuntu
            ansible_ssh_private_key_file: ~/.ssh/production/backend_private_key.pem
            ansible_become: yes

frontend_cluster:
        frontend1:
            ansible_ssh_host: "${frontend_ip}"
            ansible_ssh_port: 22
            ansible_ssh_user: ubuntu
            ansible_ssh_private_key_file: ~/.ssh/production/frontend_private_key.pem
            ansible_become: yes

aws_servers:
    children:
        backend_cluster:
	frontend_cluster:
                       EOF > ./ansible/hosts.yaml"""
                }
            }
        }
        stage("Raise docker environment in EC2s"){
            steps {
                sh 'ansible-playbook -i ./ansible/hosts.yaml ./ansible/install_docker.yaml'
            }
        }
        stage("Lunch Containers"){
            parallel {
                stage("Backend") {
                    steps {
                        sh "ansible-playbook -i hosts.yaml deploy-container.yaml --extra-vars 'HOSTS=backend_cluster NAME=Backend IMAGE=${env.DOCKER_REPO_NAME}/frontend-image:latest HOST_PORT=${env.BACK_PORT} CONTAINER_PORT=${env.BACK_PORT} MONGO_URL=${env.DB_CONNECTION}'"
                    }
                }
                stage("Frontend") {
                    steps {
                        sh "ansible-playbook -i hosts.yaml deploy-container.yaml --extra-vars 'HOSTS=frontend_cluster NAME=Frontend IMAGE=${env.DOCKER_REPO_NAME}/frontend-image:latest HOST_PORT=80 CONTAINER_PORT=${env.FRONT_PORT} MONGO_URL=NONE'"
                    }
                }
            }
        }
    }
    post {
        failure {
            withCredentials([[$class: 'AmazonWebServicesCredentialsBinding',credentialsId: "aws-cre"]]) {
                sh 'terraform -chdir="./terraform" destroy -auto-approve'
            }
        }
        cleanup {
            cleanWs()
        }
    }
}